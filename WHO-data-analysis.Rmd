---
output: 
  pdf_document:
    citation_package: natbib
    keep_tex: true
    fig_caption: true
    latex_engine: pdflatex
title: Analysis of Ebola data from WHO
author:
- name: Sangeeta Bhatia
  affiliation: Imperial College London
date: "`r format(Sys.time(), '%d %B, %Y')`"
geometry: margin=1in
fontfamily: mathpazo
fontsize: 11pt
bibliography: 
biblio-style: apsr
endnote: no
---
```{r, echo = FALSE}
library(magrittr)
library(ggplot2)
library(dplyr)
library(EpiEstim)
devtools::load_all()
```
# Data clean-up
The current data set ahs three possible values for the epidemiological
case definition - confirmed, probable and suspected.
Epidemiological case definition of probable and suspected cases
differed across countries while confirmed cases were the ones
confirmed through lab report. For the purpose of the current analysis,
one approach could be to lump all of them together. The inferred date of
onset (rather than the date reported) is used for estimation.
The columns we use are : Country, EpiCaseDef (probably),
DateOnsetInferred and CL_DistrictRes. 


```{r}
WHO_raw <- read.csv("data/CaseCounts/who/rstb20160308supp1.csv") %>%
           select(Country, EpiCaseDef,
                  DateOnsetInferred,CL_DistrictRes) %>%
           na.omit

WHO_raw$Country    %<>% factor
WHO_raw$EpiCaseDef %<>% factor
WHO_raw$CL_DistrictRes %<>% factor
WHO_raw$DateOnsetInferred %<>% as.Date
 
```


## Grouping by districts and interpolating missing data
For each district in a country, add the number of records for each
date to get incidence count.
```{r}
WHO_bydistricts <- WHO_raw %>% 
                   group_by(Country, CL_DistrictRes,
                                   DateOnsetInferred) %>%
                   summarise(incid = n())


```
Within each district, if there is a date on which no cases are
recorded, we assume that there were no cases on that date and add this
to the record. At the end of this step, the incidence time series for
each district should be a daily time series.

```{r}

add_0incid <- function(df){
    df    %<>% arrange(DateOnsetInferred)
    start <- min(df$DateOnsetInferred)
    end   <- max(df$DateOnsetInferred)
    
    dates.all <- seq(from = start, to = end, by = "1 day")
    ndays     <- length(dates.all)
    country   <- rep(df$Country[1], ndays)
    district  <- rep(df$CL_DistrictRes[1], ndays)
    dummy     <- data.frame(DateOnsetInferred = dates.all,
                            Country = country,
                            CL_DistrictRes = district)
    df %<>% right_join(dummy)
    df$incid %<>% ifelse(is.na(.), 0, . )
    return(df)    
}

WHO_bydistricts %<>%
    split(.$CL_DistrictRes) %<>%
    lapply(add_0incid) %<>%
    bind_rows

WHO_bydistricts %<>% rename(Date = DateOnsetInferred)

```

# Comparison with the data from Health Map.

First read in and clean up the data from Health Map. Since these data
are at national level, we will also aggregate the WHO data at country
level. HealthMap collects and curates data on the cumulative number
of cases (C) and deaths (D) stratified by status (suspected, SC/SD, or
confirmed CC/CD). For data from the WHO, the case status could be
confirmed, probable or suspected. The final clinical outcome (alive/dead)
for each case is also recorded. In comparing the two data sets, we sum
across all four categories in Healthmap and derive incidence data from
cumulative data.

```{r, echo = FALSE}
species   <- "Humans"
disease   <- "Ebola"
case.type <- "SCC"
healthmap <- "data/CaseCounts/raw/HealthMap_Ebola_GNE_WHO.csv" %>%
               read.csv(stringsAsFactors = FALSE) %>%
               filter(species == species,
                             disease == disease,
                             case.type == case.type,
                             Country %in% unique(WHO_raw$Country) )

healthmap_bycountry <- split(healthmap, healthmap$Country) 

healthmap_weekly    <- healthmap_bycountry %>%
                       lapply(function(case.count){
                               location <- case.count$Country[1]
                               case.count %<>%
                                  incidence.from.DS1(species, disease,
                                                   case.type,
                                                   location,
                                                   merge_rule = "median") %<>%
                                 daily.to.weekly }) %>%
                        bind_rows(.id = "Country")

WHO_bycountry <-WHO_bydistricts %>%
                 group_by(Country,Date) %>%
                 summarise(incid = sum(incid)) 


WHO_weekly <- split(WHO_bycountry, WHO_bycountry$Country) %>%
              lapply(function(df){
                      df      %>%
                      ungroup %>%
                      select(Date, incid) %>%
                      daily.to.weekly}) %>%
                bind_rows(.id = "Country")    
WHO_weekly$Date       %<>% as.Date
healthmap_weekly$Date %<>% as.Date

list( WHO = WHO_weekly,
      HealthMap = healthmap_weekly[, c("Country", "Date", "incid")]) %>%
    bind_rows(.id = "Source") %>%
    ggplot(aes(Date, incid, color = Source)) +
    geom_point() +
    facet_grid(Country ~.) +
    scale_x_date(date_labels="%d/%m/%y",date_breaks = "3 weeks") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

HealthMap numbers (after data clean-up) appear to be much bigger than
the numbers from WHO, particularly in the middle of the
epidemic. 


# Estimating Reproduction number from WHO and Healthmap Data

```{r}
mean_SI     <- 14.2
CV_SI       <- 9.6 / 14.2
SItrunc     <- 40
SI_Distr    <- sapply(0:SItrunc, function(e) DiscrSI(e, mean_SI, mean_SI * CV_SI))
SI_Distr    <- SI_Distr / sum(SI_Distr)
time_window <- 7 * 7
healthmap_R <- healthmap_bycountry %>%
               lapply(function(case.count){
                        location <- case.count$Country[1]
                        case.count %<>%
                        incidence.from.DS1(species, disease,
                                           case.type,
                                           location,
                                           merge_rule = "median")
                        start     <- 1:(length(case.count$Date) - time_window)
                        end       <- start + time_window
                        end.dates <- case.count$Date[end] 
                        res       <- EstimateR(case.count$incid,
                                               T.Start  = start ,
                                               T.End    = end,
                                               method   = "NonParametricSI",
                                               SI.Distr = SI_Distr,
                                               plot     = FALSE ,
                                               CV.Posterior = 1 ,
                                               Mean.Prior   = 1 ,
                                               Std.Prior    = 0.5)
                        res$R %<>% cbind(Date = end.dates)
                        return(res$R)}) %>%
              bind_rows(.id = "Country")

WHO_R <- WHO_bycountry    %>%
         split(.$Country) %>%
         lapply(function(case.count){
                  location  <- case.count$Country[1]
                  start     <- 1:(length(case.count$Date) - time_window)
                  end       <- start + time_window
                  end.dates <- case.count$Date[end] 
                  res       <- EstimateR(case.count$incid,
                                         T.Start  = start ,
                                         T.End    = end,
                                         method   = "NonParametricSI",
                                         SI.Distr = SI_Distr,
                                         plot     = FALSE ,
                                         CV.Posterior = 1 ,
                                         Mean.Prior   = 1 ,
                                         Std.Prior    = 0.5)
                  res$R %<>% cbind(Date = end.dates)
                  return(res$R)}) %>%
           bind_rows(.id = "Country")


list( WHO = WHO_R, HealthMap = healthmap_R) %>%
    bind_rows(.id = "Source") %>%
    ggplot(aes(Date, `Mean(R)`, color = Source)) +
    geom_line() +
    facet_grid(Country ~.) +
    scale_x_date(date_labels="%d/%m/%y",date_breaks = "3 weeks") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

# Projection using WHO data
## Projection within a country 
```{r}
WHO_SL <- WHO_bydistricts %>%
              filter(Country == "Sierra Leone") %>%
              select(-c(Country, Cases))  %>%
              na.omit

ggplot(WHO_SL, aes(Date, incid)) + geom_point() + facet_wrap(~CL_DistrictRes, ncol = 3) + theme_minimal()
```
Sierra Leone is divided into 4 provinces (ADM1). We will append
information about provinces to the above data frame since the spatial
information is available at this scale (for now, that is).

```{r}
SL_provinces <- list(Eastern  = data.frame(District = c("KAILAHUN",
                                                        "KENEMA",
                                                        "KONO")),
                     Northern = data.frame(District = c("BOMBALI",
                                                        "KAMBIA",
                                                        "KOINADUGU",
                                                        "PORT LOKO",
                                                        "TONKOLILI")),
                     Southern = data.frame(District = c("BO",
                                                         "BONTHE",
                                                         "MOYAMBA",
                                                        "PUJEHUN")),
                  Western = data.frame(District = c("WESTERN"))) %>%
               bind_rows(.id = "Province")

SL_provinces$Province %<>% as.factor
SL_provinces$District %<>% as.factor

WHO_SL %<>% left_join(SL_provinces, by = c("CL_DistrictRes" = "District"))
```

For now, we will ignore the  variation in reproduction number across
provices and use the same estimate for all provinces.


```{r}

SL_byprovince <- WHO_SL %>%
                     select(-CL_DistrictRes) %>%
                     group_by(Province, Date)  %>% 
                     summarise(count = n())  %>%
                     rename(incid = count)
SL_provinces  <- unique(WHO_SL$Province)

daterange <- SL_byprovince %>% split(.$Province) %>% 
    lapply(function(df) range(df$Date)) %>%
    data.frame

ggplot(SL_byprovince, aes(Date, incid)) + geom_point() + facet_wrap(~ Province)


```
We extract the interval for which data are available for all provinces
and then work with this set. We will proceed as we did with HealthMap data - split the data set into training and
validation sets, set up the parameters and press play.

```{r}
SL_byprovince_wide <-  SL_byprovince %>% 
                       filter(Date > "2014-04-20" &
                              Date < "2015-08-22") %>%
                       tidyr::spread(Province, incid)
```

We are now ready to estimate R and move forward with the projection
exactly as we did for HealthMap data.
```{r}
t.proj    <- 175L
start     <- 1:(length(SL_byprovince_wide$Date) - time_window)
end       <- start + time_window
end.dates <- SL_byprovince_wide[end, "Date"]
r.estim   <- SL_byprovince_wide  %>%
                   select(-Date) %>%
    plyr::alply(2, .dims = TRUE, function(incid) {
                                   I   <- pull(incid, 1) 
                                   res <- EstimateR(I, T.Start = start , T.End = end,
                                                    method = "NonParametricSI",
                                                    SI.Distr = SI_Distr,
                                                    plot = FALSE ,
                                                    CV.Posterior = 1 ,
                                                    Mean.Prior = 1 ,
                                                    Std.Prior = 0.5)
                                   res$R %<>% cbind(Date = end.dates)
                                   return(res$R)})
r.estim %>%
    bind_rows(r.estim, .id = "Province") %>%
    ggplot(aes(Date, `Mean(R)`)) +
    geom_point() +
    facet_wrap(~Province) +
    ggtitle("Mean R for each province")

n.sim <- 1000L    # Number of simulations to run
r.j.t <- r.estim %>%
           lapply(function(R){
                    cutoff <- which(R$Date %in% SL_byprovince_wide[t.proj, "Date"])
                    shape  <- R[cutoff, "Mean(R)"]^2 / R[cutoff, "Std(R)"]^2
                    scale  <- R[cutoff, "Std(R)"]^2 / R[cutoff, "Mean(R)"]
                    return(rgamma(n.sim, shape = shape,
                                         scale = scale))}) %>% data.frame

```


# Population flow matrix

```{r}
pow_N_from <- 1
pow_N_to   <- 1
pow_dist   <- 2
K          <- 1

adm1_centroids <- "data/Geography/GravityModel/raw/adm1_centroids_fixed.tsv" %>%
                   read.csv(stringsAsFactors = FALSE,
                            sep = "\t",
                            header = TRUE) %>%
                    filter(ADM0 == "Sierra Leone")

 
flow.matrix  <- flow_matrix(longitude   = adm1_centroids[, "Centroid_Lon"],
                            latitude    = adm1_centroids[, "Centroid_Lat"],
                            population  = adm1_centroids[, "Pop"],
                            place.names = adm1_centroids[, "ADM1"],
                            model = "gravity", K = K,
                            pow_N_from = pow_N_from,
                            pow_N_to   = pow_N_to,
                            pow_dist   = pow_dist)


## Relative risk
relative.risk <- flow.matrix / rowSums(flow.matrix, na.rm=TRUE)
p.stay     <- 0.99 
p.movement <- probability_movement(relative.risk, p.stay)

```

At this point, all the pieces are in place.
SL_training contains the incidence count we will use for projecting.
Estimate of R is in the data frame r.j.t with a row for each
simulation we want to run. p.movement conatins the probabilities.

```{r}
n.dates.sim   <- 42L      # The time period over which projection will be made.
SL_training   <- SL_byprovince_wide[1:t.proj, ]
SL_validation <- SL_byprovince_wide[(1 + t.proj):nrow(SL_byprovince_wide), ]

incid     <- as.matrix(select(SL_training, -Date))
dates.all <- SL_training[1:t.proj, ] %>%
             pull(Date) %>%
             c(seq(max(.) + 1, length.out = n.dates.sim, by = 1))
t.max     <- t.proj + n.dates.sim - 1


daily.projections <- plyr::alply(r.j.t, 1, function(r.t){
                                    r.t   <- as.matrix(r.t)
                                    out   <- project(incid, r.t, SI_Distr,
                                                     p.movement, n.dates.sim) 
                                    incidence.proj <- rbind(incid, out)
                                    incidence.proj %<>% data.frame
                                    incidence.proj %<>% cbind(Date = dates.all)
                                    return(incidence.proj[(nrow(SL_training) + 1):t.max, ])})


weekly.projections <- lapply(daily.projections, daily.to.weekly) %>% bind_rows(.)
```
At the same time, we will also obtain the weekly incidence count from
available data.
```{r}
weekly.available <- c(training    = list(SL_training),
                       validation = list(SL_validation)) %>%
                       lapply(daily.to.weekly) %>%
                       bind_rows(.id = "Category")


plots.list <- SL_training %>%
                 select(-Date) %>%
                 colnames %>%
                 lapply(function(location){
                         available  <- weekly.available %>%
                                       `[`(, c("Date", "Category", location))
                         projection <- weekly.projections %>%
                                       `[`(, c("Date", location))
                         plot.weekly(available, projection)})

cowplot::plot_grid(plots.list[[1]],
                        plots.list[[2]],
                        plots.list[[3]],
                        plots.list[[4]])


```
Daily incidence data are worth looking at although they might be
noisy.

```{r}
daily.available <- c(training    = list(SL_training),
                      validation = list(SL_validation)) %>%
                    bind_rows(.id = "Category")

daily.projections %<>% bind_rows(.)

plots.list <- SL_training %>%
                 select(-Date) %>%
                 colnames %>%
                 lapply(function(location){
                         available  <- daily.available %>%
                                       `[`(, c("Date", "Category", location))
                         projection <- daily.projections %>%
                                       `[`(, c("Date", location))
                         plot.weekly(available, projection)})

cowplot::plot_grid(plots.list[[1]],
                        plots.list[[2]],
                        plots.list[[3]],
                        plots.list[[4]])


```
