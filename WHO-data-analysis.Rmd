---
output: 
  pdf_document:
    citation_package: natbib
    keep_tex: true
    fig_caption: true
    latex_engine: pdflatex
title: Analysis of Ebola data from WHO
author:
- name: Sangeeta Bhatia
  affiliation: Imperial College London
date: "`r format(Sys.time(), '%d %B, %Y')`"
geometry: margin=1in
fontfamily: mathpazo
fontsize: 11pt
bibliography: 
biblio-style: apsr
endnote: no
---
```{r, echo = FALSE}
library(magrittr)
library(ggplot2)
library(dplyr)
library(EpiEstim)
devtools::load_all()
```
# Data clean-up
Epidemiological case definition of probable and suspected cases
differed across countries while confirmed cases were the ones
confirmed through lab report. For the purpose of the current analysis,
one approach could be to lump them together. The inferred date of
onset (rather than the date reported) is used for estimation.


```{r}
WHO_raw <- read.csv("data/CaseCounts/who/rstb20160308supp1.csv")
WHO_raw$DateOnsetInferred %<>% as.Date
```

## Availability of data for overlapping periods

An implicit assumption in our model is that we have incidence data for
the same dates for different locations. For data from HealthMap, even
after discarding the dates for which data for some countries were
missing, we had sufficient records to carry forward the
analysis. Since the data from WHO have been collected at a more
granular scale, this might not be true.

```{r, echo = FALSE}
daterange_wide <- function(df){
    rownames(df) <- c("MinDate", "MaxDate")
    df %>%
        tibble::rownames_to_column(var = "Variable") %>%
        tidyr::gather(Country, Dates, -Variable)     %>%
        tidyr::spread(key = Variable, value = Dates)
}
tmp <- WHO_raw %>%
       split(.$Country) %>%
       lapply(function(df) range(df$DateOnsetInferred, na.rm = TRUE)) %>%
       data.frame %>%
       daterange_wide
tmp$Country %<>% as.factor
yaxis <- seq(from = min(tmp$MinDate), to = max(tmp$MaxDate), length.out = nrow(tmp))

ggplot(tmp, aes(Country, yaxis)) +
    geom_linerange(aes(ymin = MinDate, ymax = MaxDate)) +
    ggtitle("Dates for which data are available for each country") +
    theme(plot.title = element_text(hjust = 0.5))

```

Similarly for the districts within a country.
```{r, fig.height = 9}
tmp <- WHO_raw %>%
       split(.$CL_DistrictRes) %>%
       lapply(function(df) range(df$DateOnsetInferred, na.rm = TRUE)) %>%
       data.frame
rownames(tmp) <- c("MinDate", "MaxDate")
tmp %<>%
     tibble::rownames_to_column(var = "Variable")    %<>%
     tidyr::gather(CL_DistrictRes, Dates, -Variable) %<>%
     tidyr::spread(key = Variable, value = Dates)    


districts_countries <- unique(WHO_raw[, c("CL_DistrictRes", "Country")]) %>% .[complete.cases(.), ]
tmp$CL_DistrictRes %<>%
        as.factor  %<>%
        plyr::mapvalues(from = levels(.), to = levels(districts_countries$CL_DistrictRes))

tmp %<>% dplyr::left_join(districts_countries)

tmp$Country %<>% as.factor
yaxis <- seq(from = min(tmp$MinDate), to = max(tmp$MaxDate), length.out = nrow(tmp)) 
ggplot(tmp, aes(CL_DistrictRes, yaxis)) +
     geom_linerange(aes(ymin = MinDate, ymax = MaxDate)) +
     facet_wrap(~Country, scales = "free_x", nrow = 3) +
     theme(axis.text.x=element_text(angle = -40, hjust = 0)) +
     ylab("") + xlab("Districts") +
     ggtitle("Dates for which data are available for districts within each country") +
     theme(plot.title = element_text(hjust = 0.5))

```
It seems that the data for Sierra Leone are less patchy. It might be a
good idea to start analysis with Sierra Leone.

## Grouping by districts and interpolating missing data
For each district in a country, add the number of records for each
date to get incidence count.
```{r}
WHO_bydistricts <- WHO_raw %>% 
                   dplyr::group_by(Country,
                                   DateOnsetInferred,
                                   CL_DistrictRes) %>%
                   dplyr::summarise(count = n())

ggplot(WHO_bydistricts, aes(DateOnsetInferred, count)) +
    geom_point() +
    facet_grid(Country~.) +
    xlab("Date of onset") + theme_minimal()
```

There is some missing data - the incidence time series is not a daily
time series. We will need to interpolate as the R estimation module
expects a daily time series. We do this interpolation at the district
level.

```{r}
WHO_bydistricts           %<>%
  split(.$CL_DistrictRes) %>%
  lapply(function(district){
      district %<>% na.omit
      country <- unique(district$Country)
      dis     <- unique(district$CL_DistrictRes)
      district$Cases <- cumsum(district$count)
      district %<>%
          rename(Date = DateOnsetInferred, incid = count) %<>%
          interpolate.missing.data

      district$Country        <- country
      district$CL_DistrictRes <- dis
      district$incid          <- c(0, diff(district$Cases))
      return(district) }) %>% bind_rows
```


# Comparison with the data from Health Map.

First read in and clean up the data from Health Map. Since these data
are at national level, we will also aggregate the WHO data at country
level. HealthMap collects and curates data on the cumulative number
of cases (C) and deaths (D) stratified by status (suspected, SC/SD, or
confirmed CC/CD). For data from the WHO, the case status could be
confirmed, probable or suspected. The final clinical outcome (alive/dead)
for each case is also recorded. In comparing the two data sets, we sum
across all four categories in Healthmap and derive incidence data from
cumulative data.

```{r, echo = FALSE}
species   <- "Humans"
disease   <- "Ebola"
case.type <- "SCC"
healthmap <- "data/CaseCounts/raw/HealthMap_Ebola_GNE_WHO.csv" %>%
               read.csv(stringsAsFactors = FALSE) %>%
               dplyr::filter(species == species,
                             disease == disease,
                             case.type == case.type,
                             Country %in% unique(WHO_raw$Country) )

healthmap_bycountry <- split(healthmap, healthmap$Country) 

healthmap_weekly    <- healthmap_bycountry %>%
                       lapply(function(case.count){
                               location <- case.count$Country[1]
                               case.count %<>%
                                  incidence.from.DS1(species, disease,
                                                   case.type,
                                                   location,
                                                   merge_rule = "median") %<>%
                                 daily.to.weekly }) %>%
                        dplyr::bind_rows(.id = "Country")

WHO_bycountry <- WHO_bydistricts %>%
                  dplyr::group_by(Country, Date) %>% 
                  dplyr::summarise(count = n()) %>%
                  dplyr::rename(incid = count)

WHO_weekly <- split(WHO_bycountry, WHO_bycountry$Country) %>%
              lapply(function(df){
                      df      %>%
                      ungroup %>%
                      select(Date, incid) %>%
                      daily.to.weekly}) %>%
                dplyr::bind_rows(.id = "Country")    
WHO_weekly$Date       %<>% as.Date
healthmap_weekly$Date %<>% as.Date
list( WHO = WHO_weekly,
      HealthMap = healthmap_weekly[, c("Country", "Date", "incid")]) %>%
    dplyr::bind_rows(.id = "Source") %>%
    ggplot(aes(Date, incid, color = Source)) +
    geom_point() +
    facet_grid(Country ~.) +
    scale_x_date(date_labels="%d/%m/%y",date_breaks = "3 weeks") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

HealthMap numbers (after data clean-up) appear to be much bigger than
the numbers from WHO, particularly in the middle of the
epidemic. 


# Estimating Reproduction number from WHO and Healthmap Data

```{r}
mean_SI     <- 14.2
CV_SI       <- 9.6 / 14.2
SItrunc     <- 40
SI_Distr    <- sapply(0:SItrunc, function(e) DiscrSI(e, mean_SI, mean_SI * CV_SI))
SI_Distr    <- SI_Distr / sum(SI_Distr)
time_window <- 7 * 7
healthmap_R <- healthmap_bycountry %>%
               lapply(function(case.count){
                        location <- case.count$Country[1]
                        case.count %<>%
                        incidence.from.DS1(species, disease,
                                           case.type,
                                           location,
                                           merge_rule = "median")
                        start     <- 1:(length(case.count$Date) - time_window)
                        end       <- start + time_window
                        end.dates <- case.count$Date[end] 
                        res       <- EstimateR(case.count$incid,
                                               T.Start  = start ,
                                               T.End    = end,
                                               method   = "NonParametricSI",
                                               SI.Distr = SI_Distr,
                                               plot     = FALSE ,
                                               CV.Posterior = 1 ,
                                               Mean.Prior   = 1 ,
                                               Std.Prior    = 0.5)
                        res$R %<>% cbind(Date = end.dates)
                        return(res$R)}) %>%
              bind_rows(.id = "Country")

WHO_R <- WHO_bycountry    %>%
         split(.$Country) %>%
         lapply(function(case.count){
                  location  <- case.count$Country[1]
                  start     <- 1:(length(case.count$Date) - time_window)
                  end       <- start + time_window
                  end.dates <- case.count$Date[end] 
                  res       <- EstimateR(case.count$incid,
                                         T.Start  = start ,
                                         T.End    = end,
                                         method   = "NonParametricSI",
                                         SI.Distr = SI_Distr,
                                         plot     = FALSE ,
                                         CV.Posterior = 1 ,
                                         Mean.Prior   = 1 ,
                                         Std.Prior    = 0.5)
                  res$R %<>% cbind(Date = end.dates)
                  return(res$R)}) %>%
           bind_rows(.id = "Country")


list( WHO = WHO_R, HealthMap = healthmap_R) %>%
    dplyr::bind_rows(.id = "Source") %>%
    ggplot(aes(Date, `Mean(R)`, color = Source)) +
    geom_line() +
    facet_grid(Country ~.) +
    scale_x_date(date_labels="%d/%m/%y",date_breaks = "3 weeks") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

# Projection using WHO data
## Projection within a country 
```{r}
WHO_SL <- WHO_bydistricts %>%
              filter(Country == "Sierra Leone") %>%
              select(-c(Country, Cases))  %>%
              na.omit

ggplot(WHO_SL, aes(Date, incid)) + geom_point() + facet_wrap(~CL_DistrictRes, ncol = 3) + theme_minimal()
```
Sierra Leone is divided into 4 provinces (ADM1). We will append
information about provinces to the above data frame since the spatial
information is available at this scale (for now, that is).

```{r}
SL_provinces <- list(Eastern  = data.frame(District = c("KAILAHUN",
                                                        "KENEMA",
                                                        "KONO")),
                     Northern = data.frame(District = c("BOMBALI",
                                                        "KAMBIA",
                                                        "KOINADUGU",
                                                        "PORT LOKO",
                                                        "TONKOLILI")),
                     Southern = data.frame(District = c("BO",
                                                         "BONTHE",
                                                         "MOYAMBA",
                                                        "PUJEHUN")),
                  Western = data.frame(District = c("WESTERN"))) %>%
               bind_rows(.id = "Province")

SL_provinces$Province %<>% as.factor
SL_provinces$District %<>% as.factor

WHO_SL %<>% left_join(SL_provinces, by = c("CL_DistrictRes" = "District"))
```

For now, we will ignore the  variation in reproduction number across
provices and use the same estimate for all provinces.


```{r}

SL_byprovince <- WHO_SL %>%
                     select(-CL_DistrictRes) %>%
                     group_by(Province, Date)  %>% 
                     summarise(count = n())  %>%
                     rename(incid = count)
SL_provinces  <- unique(WHO_SL$Province)

daterange <- SL_byprovince %>% split(.$Province) %>% 
    lapply(function(df) range(df$Date)) %>%
    data.frame




```
We extract the interval for which data are available for all provinces
and then work with this set. We will proceed as we did with HealthMap data - split the data set into training and
validation sets, set up the parameters and press play.

```{r}
SL_byprovince_wide <-  SL_byprovince %>% 
                       filter(Date > "2014-04-20" &
                              Date < "2015-08-22") %>%
                       tidyr::spread(Province, incid)
```

We are now ready to estimate R and move forward with the projection
exactly as we did for HealthMap data.
```{r}
t.proj    <- 133L
start     <- 1:(length(SL_byprovince_wide$Date) - time_window)
end       <- start + time_window
end.dates <- SL_byprovince_wide[end, "Date"]
r.estim   <- SL_byprovince_wide  %>%
                   select(-Date) %>%
    plyr::alply(2, .dims = TRUE, function(incid) {
                                   I   <- pull(incid, 1) 
                                   res <- EstimateR(I, T.Start = start , T.End = end,
                                                    method = "NonParametricSI",
                                                    SI.Distr = SI_Distr,
                                                    plot = FALSE ,
                                                    CV.Posterior = 1 ,
                                                    Mean.Prior = 1 ,
                                                    Std.Prior = 0.5)
                                   res$R %<>% cbind(Date = end.dates)
                                   return(res$R)})
r.estim %>%
    bind_rows(r.estim, .id = "Province") %>%
    ggplot(aes(Date, `Mean(R)`)) +
    geom_point() +
    facet_wrap(~Province) +
    ggtitle("Mean R for each province")

n.sim <- 1000L    # Number of simulations to run
r.j.t <- r.estim %>%
           lapply(function(R){
                    cutoff <- which(R$Date %in% SL_byprovince_wide[t.proj, "Date"])
                    shape  <- R[cutoff, "Mean(R)"]^2 / R[cutoff, "Std(R)"]^2
                    scale  <- R[cutoff, "Std(R)"]^2 / R[cutoff, "Mean(R)"]
                    return(rgamma(n.sim, shape = shape,
                                         scale = scale))}) %>% data.frame

```


# Population flow matrix

```{r}
pow_N_from <- 1
pow_N_to   <- 1
pow_dist   <- 2
K          <- 1

adm1_centroids <- "data/Geography/GravityModel/raw/adm1_centroids_fixed.tsv" %>%
                   read.csv(stringsAsFactors = FALSE,
                            sep = "\t",
                            header = TRUE) %>%
                    filter(ADM0 == "Sierra Leone")

 
flow.matrix  <- flow_matrix(longitude   = adm1_centroids[, "Centroid_Lon"],
                            latitude    = adm1_centroids[, "Centroid_Lat"],
                            population  = adm1_centroids[, "Pop"],
                            place.names = adm1_centroids[, "ADM1"],
                            model = "gravity", K = K,
                            pow_N_from = pow_N_from,
                            pow_N_to   = pow_N_to,
                            pow_dist   = pow_dist)


## Relative risk
relative.risk <- flow.matrix / rowSums(flow.matrix, na.rm=TRUE)
p.stay     <- 0.99 
p.movement <- probability_movement(relative.risk, p.stay)

```

At this point, all the pieces are in place.
SL_training contains the incidence count we will use for projecting.
Estimate of R is in the data frame r.j.t with a row for each
simulation we want to run. p.movement conatins the probabilities.

```{r}
n.dates.sim   <- 35L      # The time period over which projection will be made.
SL_training   <- SL_byprovince_wide[1:t.proj, ]
SL_validation <- SL_byprovince_wide[(1 + t.proj):nrow(SL_byprovince_wide), ]

incid     <- as.matrix(select(SL_training, -Date))
dates.all <- SL_training[1:t.proj, ] %>%
             pull(Date) %>%
             c(seq(max(.) + 1, length.out = n.dates.sim, by = 1))
t.max     <- t.proj + n.dates.sim - 1


daily.projections <- plyr::alply(r.j.t, 1, function(r.t){
                                    r.t   <- as.matrix(r.t)
                                    out   <- project(incid, r.t, SI_Distr,
                                                     p.movement, n.dates.sim) 
                                    incidence.proj <- rbind(incid, out)
                                    incidence.proj %<>% data.frame
                                    incidence.proj %<>% cbind(Date = dates.all)
                                    return(incidence.proj[(nrow(SL_training) + 1):t.max, ])})


weekly.projections <- lapply(daily.projections, daily.to.weekly) %>% dplyr::bind_rows(.)
```
At the same time, we will also obtain the weekly incidence count from
available data.
```{r}
weekly.available <- c(training    = list(SL_training),
                       validation = list(SL_validation)) %>%
                       lapply(daily.to.weekly) %>%
                       dplyr::bind_rows(.id = "Category")


plots.list <- SL_training %>%
                 select(-Date) %>%
                 colnames %>%
                 lapply(function(location){
                         available  <- weekly.available %>%
                                       `[`(, c("Date", "Category", location))
                         projection <- weekly.projections %>%
                                       `[`(, c("Date", location))
                         plot.weekly(available, projection)})

p <- cowplot::plot_grid(plots.list[[1]],
                        plots.list[[2]],
                        plots.list[[3]],
                        plots.list[[4]])

cowplot::save_plot("SL-Regionwise.png", p,
                    base_aspect_ratio = 1.3)

```
