---
output: 
  pdf_document:
    citation_package: natbib
    keep_tex: true
    fig_caption: true
    latex_engine: pdflatex
title: Estimation of model parameters
author:
- name: Sangeeta Bhatia
  affiliation: Imperial College London
abstract: 
keywords: 
date: "Y"
geometry: margin=1in
fontfamily: mathpazo
fontsize: 11pt
# spacing: double
bibliography: 
biblio-style: apsr
endnote: no
params:
  pow_dist : 2
  t.proj : 300
  n.sim : 2
  n.dates.sim : 49
  p.stay: 0.9
  ADM0: GUINEA
---


```{r}
library(magrittr)
library(ggthemes)
library(ggplot2)
library(dplyr)
library(rstan)
library(EpiEstim)
devtools::load_all()

```

# Simple model in Stan

We start with defining a very simple model with only one 
location. 
The model is given by 
\[
 I(t) \sim Poisson(R \sum_{s = 0}^{t}{I_{t} ws_{t - s}}).
\]

The model is tested with simulated data.

# Parameter estimation for simulated data

Load in the data and prepare to feed into Stan.

```{r ebola_params, eval = TRUE}

mean_SI     <- 14.2
CV_SI       <- 9.6 / 14.2
SItrunc     <- 40
SI_Distr    <- sapply(0:SItrunc, function(e) DiscrSI(e,
                                                     mean_SI,
                                                     mean_SI * CV_SI))
SI_Distr    <- SI_Distr / sum(SI_Distr)


```


```{r}

R <- 1.5
T <- 100

SI_len <- length(SI_Distr)
SI <- if(T < SI_len) SI_Distr[1:T]
      else c(SI_Distr, rep(0, T - SI_len))

I <- rep(0, T)
I[1] <- 100
muall <- c(0)
for(t in 2:T){
    mu <- 0
    for(s in 1:(t)){
        mu <- mu + I[s] * SI[t - s + 1]
    }
    mu <- mu * R
    muall <- c(muall, mu)
    I[t] <- rpois(1, lambda = mu)
    
}

sim_data <- list(T = T, I = I, SI = SI)

fit1 <- stan(
  file = "R/gravitymodel.stan",  # Stan program
  data = sim_data,    # named list of data
  chains = 1,             # number of Markov chains
  warmup = 1000,          # number of warmup iterations per chain
  iter = 5000,            # total number of iterations per chain
  cores = 2,              # number of cores (using 2 just for the vignette)
  refresh = 500          # show progress every 'refresh' iterations
)

print(fit1, pars=c("R"), probs=c(.1,.5,.9))
                                        #traceplot()

```

Stan can also do point estimation through optimization.

```{r stan_optim, eval = FALSE}
ocode <- readr::read_file("R/gravitymodel.stan")
sm <- stan_model(model_code = ocode)
optimizing(sm, data = sim_data, hessian = TRUE)

```

# Simulated using mRIIDS package

Simulate incidence using our very own projection module.

```{r}
I0 <- c(90)
incid <- as.matrix(I0, 1, 1)
R <- 0.5
pij <- 1 # probability of staying at i
n.days <- 5
SI <- SI[1:(n.days + 1)] 
I <- project(incid, R, SI, pij, n.days)
I <- c(I0, I)
sim_data <- list(T = length(I), I = I, SI = SI)

fit1 <- stan(
  file = "R/gravitymodel.stan",  # Stan program
  data = sim_data,    # named list of data
  chains = 1,             # number of Markov chains
  warmup = 1000,          # number of warmup iterations per chain
  iter = 5000,            # total number of iterations per chain
  cores = 2,              # number of cores (using 2 just for the vignette)
  refresh = 500          # show progress every 'refresh' iterations
)

print(fit1, pars=c("R"), probs=c(.1,.5,.9))

```

R > 1

```{r}

I0 <- c(90)
incid <- as.matrix(I0, 1, 1)
R <- 1.5
pij <- 1 # probability of staying at i
n.days <- 5
SI <- SI[1:(n.days + 1)] 
I <- project(incid, R, SI, pij, n.days)
I <- c(I0, I)
sim_data <- list(T = length(I), I = I, SI = SI)

fit1 <- stan(
  file = "R/gravitymodel.stan",  # Stan program
  data = sim_data,    # named list of data
  chains = 1,             # number of Markov chains
  warmup = 1000,          # number of warmup iterations per chain
  iter = 5000,            # total number of iterations per chain
  cores = 2,              # number of cores (using 2 just for the vignette)
  refresh = 500          # show progress every 'refresh' iterations
)

print(fit1, pars=c("R"), probs=c(.1,.5,.9))

```

More data should help one assumes.

```{r}

I0 <- c(90)
incid <- as.matrix(I0, 1, 1)
R <- 1.5
pij <- 1 # probability of staying at i
n.days <- 35
SI <- SI_Distr[1:(n.days + 1)] 
I <- project(incid, R, SI, pij, n.days)
I <- c(I0, I)
sim_data <- list(T = length(I), I = I, SI = SI)

fit1 <- stan(
  file = "R/gravitymodel.stan",  # Stan program
  data = sim_data,    # named list of data
  chains = 1,             # number of Markov chains
  warmup = 1000,          # number of warmup iterations per chain
  iter = 5000,            # total number of iterations per chain
  cores = 2,              # number of cores (using 2 just for the vignette)
  refresh = 500          # show progress every 'refresh' iterations
)

print(fit1, pars=c("R"), probs=c(.1,.5,.9))

```

Vary the initial conditions.


```{r}

I0 <- c(10, 20, 30, 15)
incid <- as.matrix(I0, 4, 1)
R <- 1.5
pij <- 1 # probability of staying at i
n.days <- 35
SI <- SI_Distr[1:(n.days + 1)] 
I <- project(incid, R, SI, pij, n.days)
I <- c(I0, I)
sim_data <- list(T = length(I), I = I, SI = SI_Distr[1:length(I)])

fit1 <- stan(
  file = "R/gravitymodel.stan",  # Stan program
  data = sim_data,    # named list of data
  chains = 1,             # number of Markov chains
  warmup = 1000,          # number of warmup iterations per chain
  iter = 5000,            # total number of iterations per chain
  cores = 2,              # number of cores (using 2 just for the vignette)
  refresh = 500          # show progress every 'refresh' iterations
)

print(fit1, pars=c("R"), probs=c(.1,.5,.9))

```

# Array of reproduction numbers

## Example 1

```{r}

I0 <- 110
incid <- as.matrix(I0, 1, 1)
R <- c(rep(1.5, times = 8), rep(1.1, times = 7), rep(0.3, times = 7))
R <- as.matrix(R, ncol = 1)
pij <- 1 # probability of staying at i
n.days <- 21
SI <- SI_Distr[1:(n.days + 1)] 
I1 <- project2(incid, R, SI, pij, n.days)
I1 <- c(I0, I1)

```


And now fitting.

```{r}
sim_data <- list(T = length(I1),
                 I = I1,
                 SI = SI_Distr[1:length(I1)],
                 num_windows = 3,
                 windows_end = c(8, 15, length(I1)))

fit1 <- stan(
  file = "R/gravitymodel.stan",  # Stan program
  data = sim_data,    # named list of data
  chains = 1,             # number of Markov chains
  warmup = 1000,          # number of warmup iterations per chain
  iter = 5000,            # total number of iterations per chain
  cores = 2,              # number of cores (using 2 just for the vignette)
  refresh = 500          # show progress every 'refresh' iterations
)

print(fit1, pars=c("R"), probs=c(.1,.5,.9))

```
Looks like it is working as expected!

## Example 2

```{r}

I0 <- c(110, 150, 200, 300)
incid <- as.matrix(I0, length(I0), 1)
R <- c(rep(1.5, times = length(I0)),
           rep(1.5, times = 7),
           rep(1.1, times = 7),
           rep(0.3, times = 7))
R <- as.matrix(R, ncol = 1)
pij <- 1 # probability of staying at i
n.days <- 21
SI <- SI_Distr[1:(n.days + 1)] 
I1 <- project2(incid, R, SI, pij, n.days)
I1 <- c(I0, I1)

```


And now fitting.

```{r}
sim_data <- list(T = length(I1),
                 I = I1,
                 SI = SI_Distr[1:length(I1)],
                 num_windows = 3,
                 windows_end = c(12, 19, length(I1)))

fit1 <- stan(
  file = "R/gravitymodel.stan",  # Stan program
  data = sim_data,    # named list of data
  chains = 1,             # number of Markov chains
  warmup = 1000,          # number of warmup iterations per chain
  iter = 5000,            # total number of iterations per chain
  cores = 2,              # number of cores (using 2 just for the vignette)
  refresh = 500          # show progress every 'refresh' iterations
)

print(fit1, pars=c("R"), probs=c(.1,.5,.9))

```
Looks like it is working as expected!




# Parameter estimation for real data

```{r data_read, eval = TRUE}

infile     <- "WHO_bycountry.csv"
infile     <- here::here("data/CaseCounts/processed/", infile)
incid_wide <- readr::read_csv(infile)

guinea_incid <- filter(incid_wide, Country == "Guinea") %>% pull(incid)

```

Discard the initial 200 days when the incidence count is really low. 

```{r}

I <- guinea_incid[201:600]
windows_end <- seq(40, length(I), by = 40)
num_windows <- length(windows_end)
T <- windows_end[num_windows]

SI_len <- length(SI_Distr)
SI <- if(T < SI_len) SI_Distr[1:T] else c(SI_Distr, rep(0, T - SI_len))
  
sim_data <- list(T = T,
                 I = I,
                 SI = SI,
                 num_windows = num_windows,
                 windows_end = windows_end)




```

And get the ball rolling

```{r}
fit1 <- stan(
  file = "R/gravitymodel.stan",  # Stan program
  data = sim_data,    # named list of data
  chains = 5,             # number of Markov chains
  warmup = 1000,          # number of warmup iterations per chain
  iter = 5000,            # total number of iterations per chain
  cores = 2,              # number of cores (using 2 just for the vignette)
  refresh = 500          # show progress every 'refresh' iterations
)

print(fit1, pars=c("R"), probs=c(.1,.5,.9))
traceplot(fit1, pars = c("p"), inc_warmup = TRUE, nrow = 1)



```

The numbers look sensible, we will carry out diagnostics later.

## Scenario 2

Use the entire dataset.

```{r}

time_window <- 49
windows_end <- seq(time_window, length(guinea_incid), by = time_window)
num_windows <- length(windows_end)
T <- windows_end[num_windows]
I <- guinea_incid[seq(T)]

SI_len <- length(SI_Distr)
SI <- if(T < SI_len) SI_Distr[1:T] else c(SI_Distr, rep(0, T - SI_len))
  
sim_data <- list(T = T,
                 I = I,
                 SI = SI,
                 num_windows = num_windows,
                 windows_end = windows_end)




```

And get the ball rolling

```{r}
fit1 <- stan(
  file = "R/gravitymodel.stan",  # Stan program
  data = sim_data,    # named list of data
  chains = 5,             # number of Markov chains
  warmup = 1000,          # number of warmup iterations per chain
  iter = 5000,            # total number of iterations per chain
  cores = 2,              # number of cores (using 2 just for the vignette)
  refresh = 500          # show progress every 'refresh' iterations
)

print(fit1, pars=c("R"), probs=c(.1,.5,.9))
traceplot(fit1, pars = c("R"), inc_warmup = TRUE, nrow = 5)



```

## Estimate R using EpiEstim

```{r restim, eval = TRUE}
windows_start <- seq(1, by = time_window, length.out = length(windows_end))
r.estim   <- EpiEstim::EstimateR(I,
                                 T.Start = windows_start ,
                                 T.End = windows_end,
                                 method = "NonParametricSI",
                                 SI.Distr = SI_Distr,
                                 plot = FALSE ,
                                 CV.Posterior = 1 ,
                                 Mean.Prior = 1 ,
                                 Std.Prior = 0.5)


```

