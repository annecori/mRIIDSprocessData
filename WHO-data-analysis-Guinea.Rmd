---
output: 
  pdf_document:
    citation_package: natbib
    keep_tex: true
    fig_caption: true
    latex_engine: pdflatex
title: Analysis of WHO Ebola data for Guinea
author:
- name: Sangeeta Bhatia
  affiliation: Imperial College London
abstract: 
keywords: 
date: "Y"
geometry: margin=1in
fontfamily: mathpazo
fontsize: 11pt
# spacing: double
bibliography: 
biblio-style: apsr
endnote: no
---

```{r}
WHO_Guinea <- WHO_bydistricts %>%
               filter(Country == "Guinea") %>%
               droplevels %>%
               na.omit

ggplot(WHO_Guinea, aes(Date, incid)) +
    geom_point() +
    facet_wrap(~CL_DistrictRes, ncol = 3) +
    theme_minimal() +
    ggtitle("Incidence in districts of Guinea")

```

## Population flow matrix

```{r}
pow_N_from <- 1
pow_N_to   <- 1
pow_dist   <- 2
K          <- 1

adm2_centroids <- "data/Geography/GravityModel/raw/adm2-fixed.txt" %>%
                   read.csv(stringsAsFactors = FALSE,
                            sep = "\t",
                            header = TRUE) %>%
                   filter(ADM0 == "Guinea")  


adm2_centroids$ADM2  %<>%
    iconv(to='ASCII//TRANSLIT')  %<>%
    gsub("\\'", '', .)  %<>%
    toupper %<>%
    factor

WHO_Guinea$CL_DistrictRes %<>%
    plyr::mapvalues(from = c("N'ZEREKORE", "KISSIDOUGO", "YOMOU" ),
                    to   = c("NZEREKORE", "KISSIDOUGOU", "YAMOU"))

```
Some of the prefectures of Guinea are not represented in the WHO
data. These are: Gaoual, Koubia, Koundara, Labe, Lelouma, Mamou
and Mandiana. Hence we will drop these from the data frame of
centroids.
	
	
```{r}
adm2_centroids %<>%
    filter(ADM2 %in% WHO_Guinea$CL_DistrictRes) %<>%
    droplevels

levels(adm2_centroids$ADM2) <- levels(WHO_Guinea$CL_DistrictRes)

adm2_centroids %<>% arrange(ADM2)
flow.matrix  <- flow_matrix(longitude   = adm2_centroids[, "Centroid_Lon"],
                            latitude    = adm2_centroids[, "Centroid_Lat"],
                            population  = adm2_centroids[, "Pop"],
                            place.names = adm2_centroids[, "ADM2"],
                            model = "gravity", K = K,
                            pow_N_from = pow_N_from,
                            pow_N_to   = pow_N_to,
                            pow_dist   = pow_dist)


## Relative risk
relative.risk <- flow.matrix / rowSums(flow.matrix, na.rm=TRUE)
p.stay        <- 0.99 
p.movement    <- probability_movement(relative.risk, p.stay)

```

We are now ready to estimate R and move forward with the projection
exactly as we did for HealthMap data.
```{r}

WHO_Guinea_wide <- WHO_Guinea %>%
                    ungroup %>%
                    select(-Country) %>%
                    tidyr::spread(CL_DistrictRes, incid, fill = 0)

t.proj    <- 147L
start     <- 2:(length(WHO_Guinea_wide$Date) - time_window)
end       <- start + time_window
end.dates <- WHO_Guinea_wide[end, "Date"]
r.estim   <- WHO_Guinea_wide  %>%
                   select(-Date) %>%
    plyr::alply(2, .dims = TRUE, function(incid) {
                                   I   <- pull(incid, 1) 
                                   res <- EstimateR(I, T.Start = start , T.End = end,
                                                    method = "NonParametricSI",
                                                    SI.Distr = SI_Distr,
                                                    plot = FALSE ,
                                                    CV.Posterior = 1 ,
                                                    Mean.Prior = 1 ,
                                                    Std.Prior = 0.5)
                                   res$R %<>% cbind(Date = end.dates)
                                   return(res$R)})
r.estim %>%
    bind_rows(.id = "County") %>%
    ggplot(aes(Date, `Mean(R)`)) +
    geom_point() +
    facet_wrap(~County) +
    ggtitle("Mean R for each county in Guinea")

n.sim <- 1000L    # Number of simulations to run

r.j.t <- r.estim %>%
           lapply(function(R){
                    cutoff <- which(R$Date %in% WHO_Guinea_wide[t.proj, "Date"])
                    shape  <- R[cutoff, "Mean(R)"]^2 / R[cutoff, "Std(R)"]^2
                    scale  <- R[cutoff, "Std(R)"]^2 / R[cutoff, "Mean(R)"]
                    return(rgamma(n.sim, shape = shape,
                                         scale = scale))}) %>% data.frame

```




At this point, all the pieces are in place.
Guinea_training contains the incidence count we will use for projecting.
Estimate of R is in the data frame r.j.t with a row for each
simulation we want to run. p.movement conatins the probabilities.

```{r}
n.dates.sim        <- 49L      # The time period over which projection will be made.
Guinea_training   <- WHO_Guinea_wide[1:t.proj, ]
Guinea_validation <- WHO_Guinea_wide[(1 + t.proj):nrow(WHO_Guinea_wide), ]

incid     <- as.matrix(select(Guinea_training, -Date))
dates.all <- Guinea_training[1:t.proj, ] %>%
             pull(Date) %>%
             c(seq(max(.) + 1, length.out = n.dates.sim, by = 1))
t.max     <- t.proj + n.dates.sim - 1


daily.projections <- plyr::alply(r.j.t, 1, function(r.t){
                                    r.t   <- as.matrix(r.t)
                                    out   <- project(incid, r.t, SI_Distr,
                                                     p.movement, n.dates.sim) 
                                    incidence.proj <- rbind(incid, out)
                                    incidence.proj %<>% data.frame
                                    incidence.proj %<>% cbind(Date = dates.all, .)
                                    colnames(incidence.proj) <- colnames(Guinea_training)
                                    return(incidence.proj[(nrow(Guinea_training) + 1):t.max, ])})


weekly.projections <- lapply(daily.projections, daily.to.weekly) %>% dplyr::bind_rows(.)

```

At the same time, we will also obtain the weekly incidence count from
available data.

```{r}
weekly.available <- c(training    = list(Guinea_training),
                       validation = list(Guinea_validation)) %>%
                       lapply(daily.to.weekly) %>%
                       dplyr::bind_rows(.id = "Category")

end <- max(dates.all) + 21
weekly.available_small <- filter(weekly.available, Date < end)

plots.list <- Guinea_training %>%
                 select(-Date) %>%
                 colnames %>%
                 lapply(function(location){
                         available  <- weekly.available_small %>%
                                       `[`(, c("Date", "Category", location))
                         projection <- weekly.projections %>%
                                       `[`(, c("Date", location))
                         plot.weekly(available, projection)})

cowplot::plot_grid(plotlist = plots.list)

```

## Visualising the projections on a map

We will only plot the incidence data from 1 week before we started
projection to the end of the projection period.


```{r}

guinea         <- rgdal::readOGR(dsn = "data/Geography/GIN_adm_shp",
                                 layer = "GIN_adm2")
guinea@data$id <- guinea@data$NAME_2
guinea.points  <- broom::tidy(guinea, region="id")
guinea.points$id %<>% factor
guinea.df      <- left_join(guinea.points, guinea@data, by="id")

guinea.df$NAME_2 %<>%
    iconv(to='ASCII//TRANSLIT')  %<>%
    gsub("\\'", '', .)  %<>%
    toupper %<>%
    factor

start           <- WHO_Guinea_wide$Date[t.proj] - 7
end             <- max(dates.all) 
available_small <- filter(weekly.available, Date > start & Date < end) %>% select(-Category)
projection_50   <- weekly.projections %>% group_by(Date) %>% summarise_all(quantile, probs = 0.5)
```

As mentioned earlier, some of the prefectures of Guinea are not
represented in the data. To prevent NAs from popping up when we plot
the data later, we will insert these missing prefectures with 0
incidence.

```{r}
missing <- !(levels(guinea.df$NAME_2) %in% levels(weekly_incid$NAME_2))
missing <- levels(guinea.df$NAME_2)[missing]
tmp     <- lapply(missing, function(m) data.frame(m = rep(0, nrow(available_small))))
available_small <- bind_cols(tmp, available_small)
colnames(available_small)[1:length(missing)] <- missing

tmp     <- lapply(missing, function(m) data.frame(m = rep(0, nrow(projection_50))))
projection_50 <- bind_cols(tmp, projection_50)
colnames( projection_50)[1:length(missing)] <- missing

```

```{r}

weekly_incid    <- list(training = available_small, projection = projection_50) %>% bind_rows(.id = "Category")
library(lubridate)
weekly_incid$week <- interval(start, weekly_incid$Date) %/% lubridate::weeks(1)
weekly_incid    %<>% tidyr::gather(key = NAME_2, value = incid, factor_key = TRUE, -c(Date, week, Category))
## to get rid of 0s as we will take log later.
weekly_incid$incid %<>% `+`(1)

levels(weekly_incid$NAME_2) <- levels(guinea.df$NAME_2)
incid_map  <- left_join(guinea.df, weekly_incid)

incid_map$Category %<>% factor(levels = c("training", "projection"))
incid_map %<>% arrange(Category)


ggplot(incid_map) + 
    aes(long, lat, group = group, fill = incid) +
    geom_polygon() +
    geom_path(color = "white" ) +
    coord_equal() +
    facet_grid(Category~week) +
    scale_fill_gradient2(low = "grey50",
                         high = "firebrick",
                         trans = "log10")
                         


```
