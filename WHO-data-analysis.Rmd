---
output: 
  pdf_document:
    citation_package: natbib
    keep_tex: true
    fig_caption: true
    latex_engine: pdflatex
title: Analysis of Ebola data from WHO
author:
- name: Sangeeta Bhatia
  affiliation: Imperial College London
date: "`r format(Sys.time(), '%d %B, %Y')`"
geometry: margin=1in
fontfamily: mathpazo
fontsize: 11pt
bibliography: 
biblio-style: apsr
endnote: no
---
```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=12, fig.height=8, echo=FALSE, warning=FALSE, message=FALSE)
```

```{r, echo = FALSE}
library(magrittr)
library(ggplot2)
library(dplyr)
library(EpiEstim)
devtools::load_all()

```
# Data clean-up
The current data set has three possible values for the epidemiological
case definition - confirmed, probable and suspected.
Epidemiological case definition of probable and suspected cases
differed across countries while confirmed cases were the ones
confirmed through lab report. For the purpose of the current analysis,
one approach could be to lump all of them together. The inferred date of
onset (rather than the date reported) is used for estimation.
The columns we use are : Country, EpiCaseDef (probably),
DateOnsetInferred and CL_DistrictRes. 


```{r}
WHO_raw <- read.csv("data/CaseCounts/who/rstb20160308supp1.csv") %>%
           select(Country, EpiCaseDef,
                  DateOnsetInferred,CL_DistrictRes) %>%
           na.omit

WHO_raw$Country    %<>% factor
WHO_raw$EpiCaseDef %<>% factor
WHO_raw$CL_DistrictRes %<>% gsub(' ', '', .)  %<>% factor
WHO_raw$DateOnsetInferred %<>% as.Date

```


## Grouping by districts and interpolating missing data
For each district in a country, add the number of records for each
date to get incidence count.
```{r}
WHO_bydistricts <- WHO_raw %>% 
                   group_by(Country, CL_DistrictRes,
                                   DateOnsetInferred) %>%
                   summarise(incid = n())

```
Within each district, if there is a date on which no cases are
recorded, we assume that there were no cases on that date and add this
to the record. At the end of this step, the incidence time series for
each district should be a daily time series.

```{r}

add_0incid <- function(df){
    df    %<>% arrange(DateOnsetInferred)
    start <- min(df$DateOnsetInferred)
    end   <- max(df$DateOnsetInferred)
    
    dates.all <- seq(from = start, to = end, by = "1 day")
    ndays     <- length(dates.all)
    country   <- rep(df$Country[1], ndays)
    district  <- rep(df$CL_DistrictRes[1], ndays)
    dummy     <- data.frame(DateOnsetInferred = dates.all,
                            Country = country,
                            CL_DistrictRes = district)
    df %<>% right_join(dummy)
    df$incid %<>% ifelse(is.na(.), 0, . )
    return(df)    
}

WHO_bydistricts %<>%
    split(.$CL_DistrictRes) %<>%
    lapply(add_0incid) %<>%
    bind_rows

WHO_bydistricts %<>% rename(Date = DateOnsetInferred)

WHO_bycountry <- WHO_bydistricts %>%
                  group_by(Country,Date) %>%
                  summarise(incid = sum(incid)) 


ggplot(WHO_bydistricts, aes(Date, incid)) +
    geom_point() +
    facet_wrap(~CL_DistrictRes) +
    theme_minimal() +
    ggtitle("Incidence in each district") +
    xlab("") + theme(axis.text.x = element_text(angle = 45, vjust = 0.2))

ggplot(WHO_bycountry, aes(Date, incid)) +
    geom_point() +
    facet_wrap(~Country) +
    theme_minimal() +
    ggtitle("Incidence in each country") +
    xlab("") + theme(axis.text.x = element_text(angle = 45, vjust = 0.2))

```

# Comparison with the data from Health Map.

First read in and clean up the data from Health Map. Since these data
are at national level, we will also aggregate the WHO data at country
level. HealthMap collects and curates data on the cumulative number
of cases (C) and deaths (D) stratified by status (suspected, SC/SD, or
confirmed CC/CD). For data from the WHO, the case status could be
confirmed, probable or suspected. The final clinical outcome (alive/dead)
for each case is also recorded. In comparing the two data sets, we sum
across all four categories in Healthmap and derive incidence data from
cumulative data.

```{r, echo = FALSE}
species   <- "Humans"
disease   <- "Ebola"
case.type <- "SCC"
healthmap <- "data/CaseCounts/raw/HealthMap_Ebola_GNE_WHO.csv" %>%
               read.csv(stringsAsFactors = FALSE) %>%
               filter(species == species,
                             disease == disease,
                             case.type == case.type,
                             Country %in% unique(WHO_raw$Country) )

healthmap_bycountry <- split(healthmap, healthmap$Country) 

healthmap_weekly    <- healthmap_bycountry %>%
                       lapply(function(case.count){
                               location <- case.count$Country[1]
                               case.count %<>%
                                  incidence.from.DS1(species, disease,
                                                   case.type,
                                                   location,
                                                   merge_rule = "median") %<>%
                                 daily.to.weekly }) %>%
                        bind_rows(.id = "Country")


WHO_weekly <- split(WHO_bycountry, WHO_bycountry$Country) %>%
              lapply(function(df){
                      df      %>%
                      ungroup %>%
                      select(Date, incid) %>%
                      daily.to.weekly}) %>%
                bind_rows(.id = "Country")    
WHO_weekly$Date       %<>% as.Date
healthmap_weekly$Date %<>% as.Date

list( WHO = WHO_weekly,
      HealthMap = healthmap_weekly[, c("Country", "Date", "incid")]) %>%
    bind_rows(.id = "Source") %>%
    ggplot(aes(Date, incid, color = Source)) +
    geom_point() +
    facet_grid(Country ~.) +
    scale_x_date(date_labels="%d/%m/%y",date_breaks = "3 weeks") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))

```


# Estimating Reproduction number from WHO and Healthmap Data

```{r}
mean_SI     <- 14.2
CV_SI       <- 9.6 / 14.2
SItrunc     <- 40
SI_Distr    <- sapply(0:SItrunc, function(e) DiscrSI(e, mean_SI, mean_SI * CV_SI))
SI_Distr    <- SI_Distr / sum(SI_Distr)
time_window <- 7 * 7
healthmap_R <- healthmap_bycountry %>%
               lapply(function(case.count){
                        location <- case.count$Country[1]
                        case.count %<>%
                        incidence.from.DS1(species, disease,
                                           case.type,
                                           location,
                                           merge_rule = "median")
                        start     <- 1:(length(case.count$Date) - time_window)
                        end       <- start + time_window
                        end.dates <- case.count$Date[end] 
                        res       <- EstimateR(case.count$incid,
                                               T.Start  = start ,
                                               T.End    = end,
                                               method   = "NonParametricSI",
                                               SI.Distr = SI_Distr,
                                               plot     = FALSE ,
                                               CV.Posterior = 1 ,
                                               Mean.Prior   = 1 ,
                                               Std.Prior    = 0.5)
                        res$R %<>% cbind(Date = end.dates)
                        return(res$R)}) %>%
              bind_rows(.id = "Country")

WHO_R <- WHO_bycountry    %>%
         split(.$Country) %>%
         lapply(function(case.count){
                  location  <- case.count$Country[1]
                  start     <- 1:(length(case.count$Date) - time_window)
                  end       <- start + time_window
                  end.dates <- case.count$Date[end] 
                  res       <- EstimateR(case.count$incid,
                                         T.Start  = start ,
                                         T.End    = end,
                                         method   = "NonParametricSI",
                                         SI.Distr = SI_Distr,
                                         plot     = FALSE ,
                                         CV.Posterior = 1 ,
                                         Mean.Prior   = 1 ,
                                         Std.Prior    = 0.5)
                  res$R %<>% cbind(Date = end.dates)
                  return(res$R)}) %>%
           bind_rows(.id = "Country")


list( WHO = WHO_R, HealthMap = healthmap_R) %>%
    bind_rows(.id = "Source") %>%
    ggplot(aes(Date, `Mean(R)`, color = Source)) +
    geom_line() +
    facet_grid(Country ~.) +
    scale_x_date(date_labels="%d/%m/%y",date_breaks = "3 weeks") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

The graphs show that the estimates from the two different sources
closely track each other. Here's another way to visualise this.

```{r}

HM_vs_WHO <- list( WHO = WHO_R, HealthMap = healthmap_R) %>%
              bind_rows(.id = "Source") %>%
              select(Country, Source, Date, `Mean(R)`)

HM_vs_WHO %<>%
    tidyr::spread(Source, `Mean(R)`) %<>%
    filter(complete.cases(.))

ggplot(HM_vs_WHO, aes(HealthMap, WHO)) +
    geom_point() +
    facet_wrap(~Country, nrow = 3) +
    xlab("R estimated from HealthMap data") +
    ylab("R estimated from WHO data") +
    geom_abline(slope = 1)

```

# Projection using WHO data
## Projection within a country 

```{r}
WHO_SL <- WHO_bydistricts %>%
              filter(Country == "Sierra Leone") %>%
              droplevels %>% na.omit

ggplot(WHO_SL, aes(Date, incid)) +
    geom_point() +
    facet_wrap(~CL_DistrictRes, ncol = 3) +
    theme_minimal() +
    ggtitle("Incidence in the districts of Sierra Leone")

```


We will proceed as we did with HealthMap data - split the data set into training and
validation sets, set up the parameters and press play.

```{r}
SL_wide <-  WHO_SL %>%
            ungroup %>%
            select(-Country) %>%
            tidyr::spread(CL_DistrictRes, incid, fill = 0)
               

```

We are now ready to estimate R and move forward with the projection
exactly as we did for HealthMap data.
```{r}
mean_SI     <- 14.2
CV_SI       <- 9.6 / 14.2
SItrunc     <- 40
SI_Distr    <- sapply(0:SItrunc, function(e) DiscrSI(e, mean_SI, mean_SI * CV_SI))
SI_Distr    <- SI_Distr / sum(SI_Distr)
time_window <- 7 * 7


start     <- 2:(length(SL_wide$Date) - time_window)
end       <- start + time_window
end.dates <- SL_wide[end, "Date"]
r.estim   <- SL_wide  %>%
                   select(-Date) %>%
    plyr::alply(2, .dims = TRUE, function(incid) {
                                   I   <- pull(incid, 1) 
                                   res <- EstimateR(I, T.Start = start , T.End = end,
                                                    method = "NonParametricSI",
                                                    SI.Distr = SI_Distr,
                                                    plot = FALSE ,
                                                    CV.Posterior = 1 ,
                                                    Mean.Prior = 1 ,
                                                    Std.Prior = 0.5)
                                   res$R %<>% cbind(Date = end.dates)
                                   return(res$R)})
r.estim %>%
    bind_rows(.id = "District") %>%
    ggplot(aes(Date, `Mean(R)`)) +
    geom_point() +
    facet_wrap(~District) +
    ggtitle("Mean R for each district in Sierra Leone")

n.sim  <- 1000L    # Number of simulations to run
t.proj <- 300L
r.j.t  <- r.estim %>%
           lapply(function(R){
                    cutoff <- which(R$Date %in% SL_wide[t.proj, "Date"])
                    shape  <- R[cutoff, "Mean(R)"]^2 / R[cutoff, "Std(R)"]^2
                    scale  <- R[cutoff, "Std(R)"]^2 / R[cutoff, "Mean(R)"]
                    return(rgamma(n.sim, shape = shape,
                                  scale = scale))}) %>%
            data.frame(check.names = F)

```


# Population flow matrix

```{r}
pow_N_from <- 1
pow_N_to   <- 1
pow_dist   <- 2
K          <- 1

adm2_centroids <- "data/Geography/GravityModel/raw/adm2.txt" %>%
                   read.csv(stringsAsFactors = FALSE,
                            sep = "\t",
                            header = TRUE) %>%
                   filter(ADM0 == "Sierra Leone")  %>%
                   filter(ADM2 != "Western Rural") 

adm2_centroids$ADM2 %<>% gsub("Western Urban", "Western", .)
adm2_centroids$ADM2  %<>%
    gsub(' ', '', .) %<>%
    toupper %<>%
    factor

levels(adm2_centroids$ADM2) <- levels(WHO_SL$CL_DistrictRes)
adm2_centroids %<>% arrange(ADM2)
 
flow.matrix  <- flow_matrix(longitude   = adm2_centroids[, "Centroid_Lon"],
                            latitude    = adm2_centroids[, "Centroid_Lat"],
                            population  = adm2_centroids[, "Pop"],
                            place.names = adm2_centroids[, "ADM2"],
                            model = "gravity", K = K,
                            pow_N_from = pow_N_from,
                            pow_N_to   = pow_N_to,
                            pow_dist   = pow_dist)


## Relative risk
relative.risk <- flow.matrix / rowSums(flow.matrix, na.rm=TRUE)
p.stay     <- 0.99 
p.movement <- probability_movement(relative.risk, p.stay)

```

At this point, all the pieces are in place.
SL_training contains the incidence count we will use for projecting.
Estimate of R is in the data frame r.j.t with a row for each
simulation we want to run. p.movement conatins the probabilities.

```{r, warning=FALSE}
n.dates.sim   <- 49L      # The time period over which projection will be made.
SL_training   <- SL_wide[1:t.proj, ]
SL_validation <- SL_wide[(1 + t.proj):nrow(SL_wide), ]

incid     <- as.matrix(select(SL_training, -Date))
dates.all <- SL_training[1:t.proj, ] %>%
             pull(Date) %>%
             c(seq(max(.) + 1, length.out = n.dates.sim, by = 1))
t.max     <- t.proj + n.dates.sim - 1


daily.projections <- plyr::alply(r.j.t, 1, function(r.t){
                                    r.t   <- as.matrix(r.t)
                                    out   <- project(incid, r.t, SI_Distr,
                                                     p.movement, n.dates.sim) 
                                    incidence.proj <- rbind(incid, out)
                                    incidence.proj %<>% data.frame(check.names = F)
                                    incidence.proj %<>% cbind(Date = dates.all)
                                    return(incidence.proj[(nrow(SL_training) + 1):t.max, ])})


weekly.projections <- lapply(daily.projections, daily.to.weekly) %>% bind_rows(.)

```
At the same time, we will also obtain the weekly incidence count from
available data.

```{r, warning=FALSE}
weekly.available <- c(training    = list(SL_training),
                       validation = list(SL_validation)) %>%
                       lapply(daily.to.weekly) %>%
                       bind_rows(.id = "Category")

plots.list <- SL_training %>%
                 select(-Date) %>%
                 colnames %>%
                 lapply(function(location){
                         available  <- weekly.available %>%
                                       `[`(, c("Date", "Category", location))
                         projection <- weekly.projections %>%
                                       `[`(, c("Date", location))
                         plot.weekly(available, projection)})

cowplot::plot_grid(plots.list[[1]],
                        plots.list[[2]],
                        plots.list[[3]],
                        plots.list[[4]],
                        plots.list[[5]],
                        plots.list[[6]],
                        plots.list[[7]],
                        plots.list[[8]],
                        plots.list[[9]],
                        plots.list[[10]],
                        plots.list[[11]],
                        plots.list[[12]],
                        plots.list[[13]])                   
 

```
Daily incidence data are worth looking at although they might be
noisy.

```{r}
daily.available <- c(training    = list(SL_training),
                      validation = list(SL_validation)) %>%
                    bind_rows(.id = "Category")

daily.projections %<>% bind_rows(.)

plots.list <- SL_training %>%
                 select(-Date) %>%
                 colnames %>%
                 lapply(function(location){
                         available  <- daily.available %>%
                                       `[`(, c("Date", "Category", location))
                         projection <- daily.projections %>%
                                       `[`(, c("Date", location))
                         plot.weekly(available, projection)})

cowplot::plot_grid(plots.list[[1]],
                        plots.list[[2]],
                        plots.list[[3]],
                        plots.list[[4]],
                        plots.list[[5]],
                        plots.list[[6]],
                        plots.list[[7]],
                        plots.list[[8]],
                        plots.list[[9]],
                        plots.list[[10]],
                        plots.list[[11]],
                        plots.list[[12]],
                        plots.list[[13]])                   


```

